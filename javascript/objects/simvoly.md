---
description: Что такое символы и для чего они нужны
---

# Символы

В качестве ключей для свойств объекта могут использоваться только строки или символы.

"Символ" — это уникальный идентификатор.

Синтаксис:

{% code overflow="wrap" %}
```javascript
let id = Symbol();

// Символу можно дать описание (так называемое имя)
let name = Symbol("name")
```
{% endcode %}

Каждый символ уникален. Даже если создать множество символом с одинаковым описанием, то они все равно будут разные. Описание — это просто метка, которая не влияет ни на что.

{% code overflow="wrap" %}
```javascript
let id1 = Symbol("id")
let id2 = Symbol("id")
let id3 = Symbol("id")

console.log(id1 == id2) // False
```
{% endcode %}

## Преобразование в строки

Символы не преобразуются в строки автоматически.

```javascript
let id = Symbol("id");

alert(id) // TypeError. Однако Node.js сконвертирует

// Для преобразования необходимо использовать .toString()
alert(id.toString());

// Можно обратиться к описанию
alert(id.description) // id
```

## Скрытые свойства

Символы позволяют создавать скрытые свойства.&#x20;

```javascript
let user = {
    name: "Vasya"
};

let id = Symbol("id");
user[id] = 1;

alert( user[id] ); // 1. Можно получить доступ по ключу-символу
```

Так как объект `user` принадлежит стороннему коду, то нам не следует добавлять к нему какие-либо поля. Это небезопасно. Но к символу сложно нечаянно обратиться, так как сторонний код вряд ли его вообще увидит.&#x20;

## В литеральном объекте

Если мы хотим включить символ в сам объект, созданный литеральным способом, то символ необходимо заключить в квадратные скобки.

```javascript
let id = Symbol("id");

let user = {
    name: "Vasya",
    [id]: 1 // Просто id не прокатит
}

alert( user[id] )
```

{% hint style="info" %}
Символы игнорируются циклом `for...in`.
{% endhint %}

```javascript
let id = Symbol("id");

let user = {
    name: "Vasya",
    [id]: 1
}

for (let key in user) alert(key) // undefined
```

Однако метод `Object.assign()` копирует и строковые, и символьные свойства

```javascript
let id = Symbol("id");

let user = {
    name: "Vasya",
    [id]: 1
};

let clone = Object.assign( {}, user );

alert( clone[id] ) // 1
```

## Глобальные символы

Если мы хотим обращаться к одному и тому же символу, то для этого существует глобальный реестр символов. Мы можем создавать в нем символы и обращаться к ним позже, и при каждом обращении нам будет возвращаться один и тот же символ.

```javascript
// Читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан
let idAgain = Symbol.for("id"); // читаем и снова записываем в другую переменную

// Проверяем
alert( id === idAgain ) // true
```

## Обратный метод

Существует обратный метод `Symbol.keyFor()`, который принимает глобальный символ и возвращает его имя (метку).

```javascript
let sym = Symbol.for("id");

alert( Symbol.keyFor(sym) ) // id
```

## Системный символы

Существует множество "системных" символов, которые используются внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.

* `Symbol.hasInstance`
* `Symbol.isConcatSpreadable`
* `Symbol.iterator`
* `Symbol.toPrimitive`
* ...

Скоро будет подробное объяснение символам
