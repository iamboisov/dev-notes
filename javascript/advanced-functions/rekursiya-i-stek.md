---
description: Продвинутая работа с функциями
---

# Рекурсия и стек

{% hint style="info" %}
Рекурсия — это прием программирования, полезный в ситуациях, когда задача может быть разделена на несколько аналогичных, но более простых задач. Когда функция вызывает сама себя — это называется рекурсией.
{% endhint %}

## Два способы мышления

В качестве первого примера напишем функцию `pow(x, n)`, которая возводит `x` в натуральную степень `n`. Иначе говоря, умножает `x` на само себя `n` раз.

```javascript
pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
```

#### Итеративный способ

```javascript
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x
  }

  console.log(result)
}

pow(2, 4) // 16
```

#### Рекурсивный способ

{% code overflow="wrap" %}
```javascript
function pow(x, n) {
  result = x

  if (n != 1) {
    result *= pow(x, n-1) // Создается цепочка вызовов с уменьшением n. В конечном итоге n становится равен 1, единица возвращается и стек вызовов выполняется с конца.
  }

  return result
}

console.log(pow(2, 4))
```
{% endcode %}

Говорят, что функция `pow` _рекурсивно вызывает саму себя_ до `n == 1`.

{% hint style="info" %}
Общее количество вложенных вызовов (включая первый) называют _глубиной рекурсии_. В нашем случае она будет равна `n`.
{% endhint %}

Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей.

## Контекст выполнения, стек

Контекст выполнения — это специальная внутренняя структура данных, которая содержит информацию о вызовы функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение `this` и прочую служебную информацию.

**Когда функция производит вложенный вызов, происходит следующее:**

* Выполнение текущей функции приостанавливается.
* Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – _стеке контекстов выполнения_.
* Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
* После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.

Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, и в данном случае это приводит к тому, что возведение в степень `n` хранит в памяти `n` различных контекстов.

{% hint style="info" %}
Реализация возведения в степень через цикл гораздо более экономна.
{% endhint %}

Итеративный вариант функции `pow` использует один контекст, в котором будут последовательно меняться значения `i` и `result`. При этом объём затрачиваемой памяти небольшой, фиксированный и не зависит от `n`.

{% hint style="success" %}
Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
{% endhint %}

## Рекурсивный обход

Представьте, у нас есть компания. Структура персонала может быть представлена как объект, то есть в компании могут быть отделы. Нам нужна функция для получения суммы всех зарплат. Как это можно сделать?

**Упрощенный пример (чтобы понять, что будет дальше в более сложном примере):**

{% code overflow="wrap" %}
```javascript
let company = {
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }]
};
```
{% endcode %}

Так как наш объект состоит из ключа sales и значения в виде массива из объектов, то сумму зарплат мы можем получить перебрав массив (то есть значение по ключу sales)

{% code overflow="wrap" %}
```javascript
let company = {
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }]
};


function sumSalaries(department) {
// Получаем значение (массив из объектов) по ключу sales
let value = department.sales

// Перебираем элементы массива, используя метод reduce и суммируем каждое значение по ключу salary (current.salary)
let sum = value.reduce( (previous, current) => previous + current.salary, 0 )
console.log(sum) // 1600
}
```
{% endcode %}

**Сложный пример:**

Теперь наш объект состоит из вложенных свойств.

```javascript
let company = {
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};
```

Здесь нам поможет рекурсия:

<pre class="language-javascript"><code class="lang-javascript">function sumSalaries(department) {
if (Array.isArray(department)) {
  return department.reduce((prev, current) => prev + current.salary, 0)
} else {
  let sum = 0;
<strong>  for (let subDep of Object.values(department)) {
</strong>    sum += sumSalaries(subDep)
  }
  return sum
}
return sum
}

console.log(sumSalaries(company)); // 6700
</code></pre>

Что-то на непонятном...

Давайте разбираться:

{% code overflow="wrap" %}
```javascript
function sumSalaries(department) {

// Так как свойство может быть объектом и состоять из других свойств, то нам достаточно проверить является ли оно массивом.
// Если свойство является массивом, то мы просто перебираем его с помощью reduce и выдаем результат
if (Array.isArray(department)) {

// Эта строчка с перебором массива нам понятна. Мы получаем массив из объектов и перебираем его, по ходу суммируя значения current.salary
  return department.reduce((prev, current) => prev + current.salary, 0)
  
  // Если свойство не является массивом, то мы сначала получаем новый массив (вспоминаем Object.values()) из значений свойства (которое является объектом) и перебираем его, вызывая на каждом этапе эту же функцию, но с другим параметром (массивом, полученным в ходе итерации)
} else {
  let sum = 0;
  for (let subDep of Object.values(department)) {
  
  // Так как мы получили массив, вызвав эту же функцию, мы просто вернем результат (сумму зарплат) в ходе перебора с помощью reduce и прибавим к переменной sum
  // Здесь мы вызываем функцию и она уже обращается к reduce, а та в свою очередь возвращает значение и записывает его в sum
    sum += sumSalaries(subDep)
  }
  
  // Просто возвращаем значение sum после завершения условной конструкции
  return sum
}

// Возвращаем результат выполнения функции
return sum
}

console.log(sumSalaries(company)); // 6700
```
{% endcode %}
